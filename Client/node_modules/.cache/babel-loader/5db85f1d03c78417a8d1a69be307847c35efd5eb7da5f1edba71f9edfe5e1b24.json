{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/my_house/Client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"D:/my_house/Client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport ascending from \"./ascending.js\";\nimport permute from \"./permute.js\";\nexport default function sort(values) {\n  for (var _len = arguments.length, F = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    F[_key - 1] = arguments[_key];\n  }\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  var _F = F,\n    _F2 = _slicedToArray(_F, 1),\n    _F2$ = _F2[0],\n    f = _F2$ === void 0 ? ascending : _F2$;\n  if (f.length === 1 || F.length > 1) {\n    var index = Uint32Array.from(values, function (d, i) {\n      return i;\n    });\n    if (F.length > 1) {\n      F = F.map(function (f) {\n        return values.map(f);\n      });\n      index.sort(function (i, j) {\n        var _iterator = _createForOfIteratorHelper(F),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _f = _step.value;\n            var c = ascending(_f[i], _f[j]);\n            if (c) return c;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort(function (i, j) {\n        return ascending(f[i], f[j]);\n      });\n    }\n    return permute(values, index);\n  }\n  return values.sort(f);\n}","map":{"version":3,"names":["ascending","permute","sort","values","F","Symbol","iterator","TypeError","Array","from","f","length","index","Uint32Array","d","i","map","j","c"],"sources":["D:/my_house/Client/node_modules/d3-array/src/sort.js"],"sourcesContent":["import ascending from \"./ascending.js\";\r\nimport permute from \"./permute.js\";\r\n\r\nexport default function sort(values, ...F) {\r\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\r\n  values = Array.from(values);\r\n  let [f = ascending] = F;\r\n  if (f.length === 1 || F.length > 1) {\r\n    const index = Uint32Array.from(values, (d, i) => i);\r\n    if (F.length > 1) {\r\n      F = F.map(f => values.map(f));\r\n      index.sort((i, j) => {\r\n        for (const f of F) {\r\n          const c = ascending(f[i], f[j]);\r\n          if (c) return c;\r\n        }\r\n      });\r\n    } else {\r\n      f = values.map(f);\r\n      index.sort((i, j) => ascending(f[i], f[j]));\r\n    }\r\n    return permute(values, index);\r\n  }\r\n  return values.sort(f);\r\n}\r\n"],"mappings":";;AAAA,OAAOA,SAAS,MAAM,gBAAgB;AACtC,OAAOC,OAAO,MAAM,cAAc;AAElC,eAAe,SAASC,IAAI,CAACC,MAAM,EAAQ;EAAA,kCAAHC,CAAC;IAADA,CAAC;EAAA;EACvC,IAAI,OAAOD,MAAM,CAACE,MAAM,CAACC,QAAQ,CAAC,KAAK,UAAU,EAAE,MAAM,IAAIC,SAAS,CAAC,wBAAwB,CAAC;EAChGJ,MAAM,GAAGK,KAAK,CAACC,IAAI,CAACN,MAAM,CAAC;EAC3B,SAAsBC,CAAC;IAAA;IAAA;IAAlBM,CAAC,qBAAGV,SAAS;EAClB,IAAIU,CAAC,CAACC,MAAM,KAAK,CAAC,IAAIP,CAAC,CAACO,MAAM,GAAG,CAAC,EAAE;IAClC,IAAMC,KAAK,GAAGC,WAAW,CAACJ,IAAI,CAACN,MAAM,EAAE,UAACW,CAAC,EAAEC,CAAC;MAAA,OAAKA,CAAC;IAAA,EAAC;IACnD,IAAIX,CAAC,CAACO,MAAM,GAAG,CAAC,EAAE;MAChBP,CAAC,GAAGA,CAAC,CAACY,GAAG,CAAC,UAAAN,CAAC;QAAA,OAAIP,MAAM,CAACa,GAAG,CAACN,CAAC,CAAC;MAAA,EAAC;MAC7BE,KAAK,CAACV,IAAI,CAAC,UAACa,CAAC,EAAEE,CAAC,EAAK;QAAA,2CACHb,CAAC;UAAA;QAAA;UAAjB,oDAAmB;YAAA,IAARM,EAAC;YACV,IAAMQ,CAAC,GAAGlB,SAAS,CAACU,EAAC,CAACK,CAAC,CAAC,EAAEL,EAAC,CAACO,CAAC,CAAC,CAAC;YAC/B,IAAIC,CAAC,EAAE,OAAOA,CAAC;UACjB;QAAC;UAAA;QAAA;UAAA;QAAA;MACH,CAAC,CAAC;IACJ,CAAC,MAAM;MACLR,CAAC,GAAGP,MAAM,CAACa,GAAG,CAACN,CAAC,CAAC;MACjBE,KAAK,CAACV,IAAI,CAAC,UAACa,CAAC,EAAEE,CAAC;QAAA,OAAKjB,SAAS,CAACU,CAAC,CAACK,CAAC,CAAC,EAAEL,CAAC,CAACO,CAAC,CAAC,CAAC;MAAA,EAAC;IAC7C;IACA,OAAOhB,OAAO,CAACE,MAAM,EAAES,KAAK,CAAC;EAC/B;EACA,OAAOT,MAAM,CAACD,IAAI,CAACQ,CAAC,CAAC;AACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}